#!/usr/bin/env bash
#
# claude-env - Run Claude Code with .env file loaded as environment variables
#
# Usage: claude-env [OPTIONS] [-- claude-args...]
#
# Configuration:
#   CLAUDE_ENV_FILE - Override path to .env file (default: .env in current directory)
#

set -euo pipefail

# Version
VERSION="1.0.0"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
ENV_FILE=""
ENV_SOURCE=""

log_error() {
    echo -e "${RED}Error:${NC} $1" >&2
}

log_warn() {
    echo -e "${YELLOW}Warning:${NC} $1" >&2
}

log_info() {
    echo -e "${GREEN}claude-env:${NC} $1" >&2
}

log_step() {
    echo -e "${BLUE}[*]${NC} $1" >&2
}

find_env_file() {
    # 1. Explicit override via env var always wins
    if [ -n "${CLAUDE_ENV_FILE:-}" ] && [ -f "$CLAUDE_ENV_FILE" ]; then
        ENV_SOURCE="from CLAUDE_ENV_FILE env"
        echo "$CLAUDE_ENV_FILE"
        return 0
    fi

    # 2. Walk up from current directory to find .env
    local dir="$PWD"
    local git_root=""

    # Find git root if in a repo
    if git rev-parse --git-dir &>/dev/null 2>&1; then
        git_root="$(git rev-parse --show-toplevel 2>/dev/null)"
    fi

    while [ "$dir" != "/" ]; do
        if [ -f "$dir/.env" ]; then
            ENV_SOURCE="auto-discovered"
            echo "$dir/.env"
            return 0
        fi

        # Stop at git root
        if [ -n "$git_root" ] && [ "$dir" = "$git_root" ]; then
            break
        fi

        dir="$(dirname "$dir")"
    done

    # 3. Fall back to global
    local global="$HOME/.config/claude-env/.env"
    if [ -f "$global" ]; then
        ENV_SOURCE="global fallback"
        echo "$global"
        return 0
    fi

    return 1
}

check_dependencies() {
    if ! command -v claude &> /dev/null; then
        log_error "Claude Code is not installed"
        echo ""
        echo "Install with:"
        echo "  npm install -g @anthropic-ai/claude-code"
        exit 1
    fi
}

get_script_dir() {
    # Portable way to get script directory (works on macOS and Linux)
    local source="${BASH_SOURCE[0]}"
    while [ -L "$source" ]; do
        local dir
        dir="$(cd -P "$(dirname "$source")" && pwd)"
        source="$(readlink "$source")"
        [[ $source != /* ]] && source="$dir/$source"
    done
    cd -P "$(dirname "$source")" && pwd
}

show_version() {
    echo "claude-env version $VERSION"

    # Show git info if available
    local script_dir
    script_dir="$(get_script_dir)"
    local repo_dir
    repo_dir="$(dirname "$script_dir")"

    if [ -d "$repo_dir/.git" ]; then
        local commit
        commit=$(git -C "$repo_dir" rev-parse --short HEAD 2>/dev/null || echo "unknown")
        local branch
        branch=$(git -C "$repo_dir" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")
        echo "git: $branch@$commit"
    fi
}

show_help() {
    cat << 'EOF'
claude-env - Run Claude Code with .env file loaded

USAGE:
    claude-env [OPTIONS] [claude-args...]

OPTIONS:
    --help          Show this help message
    --version       Show version information
    --verbose       Show which .env file is being used
    --check         Validate setup without running Claude
    --edit          Edit .env file with $EDITOR
    --view          View .env contents (be careful with secrets!)
    --upgrade       Update claude-env to latest version
    --env FILE      Override .env file path

    All other flags (like -c, -p, etc.) are passed through to Claude.

ENV FILE DISCOVERY:
    claude-env automatically finds your .env file (first match wins):

    1. CLAUDE_ENV_FILE environment variable (explicit override)
    2. --env FILE flag (explicit override)
    3. .env in current directory or parent directories (up to git root)
    4. Global fallback: ~/.config/claude-env/.env

    Use --check to see which file is discovered.

ENVIRONMENT:
    CLAUDE_ENV_FILE  Override .env file path (highest priority)
    EDITOR           Editor to use for --edit (default: vim)

EXAMPLES:
    # Run Claude with auto-discovered .env
    claude-env

    # Run Claude with a specific .env file
    claude-env --env ~/projects/myapp/.env

    # Validate setup and see which file is used
    claude-env --check

    # Edit the .env file
    claude-env --edit

    # Pass arguments to Claude
    claude-env -- -p "fix the bug"

SETUP:
    1. Create a .env file in your project:
       echo "GITHUB_TOKEN=ghp_xxx" > .env
       echo "ANTHROPIC_API_KEY=sk-ant-xxx" >> .env

    2. Make sure .env is in your .gitignore:
       echo ".env" >> .gitignore

    3. Run Claude with environment loaded:
       claude-env

EOF
}

do_upgrade() {
    log_info "Upgrading claude-env..."
    local script_dir
    script_dir="$(get_script_dir)"
    local repo_dir
    repo_dir="$(dirname "$script_dir")"

    if [ -d "$repo_dir/.git" ]; then
        log_step "Pulling latest changes from git..."
        if git -C "$repo_dir" pull; then
            log_info "Upgraded successfully!"
            show_version
        else
            log_error "Failed to pull updates"
            exit 1
        fi
    else
        log_error "Not installed from git repository: $repo_dir"
        echo ""
        echo "Reinstall with:"
        echo "  curl -fsSL https://raw.githubusercontent.com/jordanburke/claude-env/main/install.sh | bash"
        exit 1
    fi
}

do_check() {
    check_dependencies

    if [ -z "${ENV_FILE:-}" ]; then
        if ! ENV_FILE=$(find_env_file); then
            log_warn "No .env file found"
            echo ""
            echo "Searched locations:"
            echo "  - .env (in current directory and parents up to git root)"
            echo "  - ~/.config/claude-env/.env (global)"
            echo ""
            echo "Create one with:"
            echo "  echo 'MY_VAR=value' > .env"
            exit 1
        fi
    fi

    log_info "Setup validated successfully!"
    echo ""
    echo "Env file: $ENV_FILE ($ENV_SOURCE)"
    echo ""
    echo "Variables that will be exported:"
    # Show variable names only (not values for security)
    grep -v '^\s*#' "$ENV_FILE" 2>/dev/null | grep -v '^\s*$' | cut -d'=' -f1 | sed 's/^/  /' || echo "  (none)"
}

do_edit() {
    if [ -z "${ENV_FILE:-}" ]; then
        if ! ENV_FILE=$(find_env_file); then
            # Create default .env in current directory
            ENV_FILE=".env"
            log_info "Creating new .env file: $ENV_FILE"
        fi
    fi

    local editor="${EDITOR:-vim}"
    log_info "Editing: $ENV_FILE"
    "$editor" "$ENV_FILE"
}

do_view() {
    if [ -z "${ENV_FILE:-}" ]; then
        if ! ENV_FILE=$(find_env_file); then
            log_error "No .env file found"
            exit 1
        fi
    fi

    log_warn "Showing contents of: $ENV_FILE"
    echo ""
    cat "$ENV_FILE"
}

main() {
    local verbose=false
    local check_only=false
    local claude_args=()

    # Parse arguments - only intercept long-form claude-env options
    # All short flags pass through to Claude (e.g., -c, -p, -r)
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help)
                show_help
                exit 0
                ;;
            --version)
                show_version
                exit 0
                ;;
            --verbose)
                verbose=true
                shift
                ;;
            --check)
                check_only=true
                shift
                ;;
            --edit)
                do_edit
                exit 0
                ;;
            --view)
                do_view
                exit 0
                ;;
            --upgrade)
                do_upgrade
                exit 0
                ;;
            --env)
                ENV_FILE="$2"
                ENV_SOURCE="from --env flag"
                shift 2
                ;;
            --)
                shift
                claude_args=("$@")
                break
                ;;
            *)
                # Pass everything else through to Claude
                claude_args+=("$1")
                shift
                ;;
        esac
    done

    # Handle --check
    if [ "$check_only" = true ]; then
        do_check
        exit 0
    fi

    # Check dependencies
    check_dependencies

    # Find env file
    if [ -z "${ENV_FILE:-}" ]; then
        if ENV_FILE=$(find_env_file); then
            if [ "$verbose" = true ]; then
                log_info "Loading: $ENV_FILE ($ENV_SOURCE)"
            fi
        else
            # No .env file found - just run claude without extra env vars
            if [ "$verbose" = true ]; then
                log_warn "No .env file found, running Claude without extra environment"
            fi
            if [ ${#claude_args[@]} -eq 0 ]; then
                exec claude
            else
                exec claude "${claude_args[@]}"
            fi
        fi
    else
        if [ "$verbose" = true ]; then
            log_info "Loading: $ENV_FILE ($ENV_SOURCE)"
        fi
    fi

    # Verify file exists
    if [ ! -f "$ENV_FILE" ]; then
        log_error "Env file not found: $ENV_FILE"
        exit 1
    fi

    # Load environment and run Claude
    set -a
    # shellcheck source=/dev/null
    source "$ENV_FILE"
    set +a

    if [ ${#claude_args[@]} -eq 0 ]; then
        exec claude
    else
        exec claude "${claude_args[@]}"
    fi
}

main "$@"
